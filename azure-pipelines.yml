# Azure Pipelines YAML para Build e Release
# Build: Compila, testa e publica artefatos
# Release: Faz deploy automático no Azure App Service

trigger:
  branches:
    include:
      - main
      - master
  paths:
    exclude:
      - README.md
      - '*.md'

pr:
  branches:
    include:
      - main
      - master

variables:
  - group: skillbridge-variables
  - name: buildConfiguration
    value: 'Release'
  - name: projectPath
    value: 'SkillBridge.API/SkillBridge.API.csproj'
  - name: testProjectPath
    value: 'SkillBridge.Tests/SkillBridge.Tests.csproj'
  - name: DB_CONNECTION_STRING
    value: 'Host=$(DB_SERVER);Database=$(DB_NAME);Username=$(DB_USER);Password=$(DB_PASSWORD);SSL Mode=Require;Trust Server Certificate=true'
  - name: RESOURCE_GROUP_NAME
    value: 'rg-skillbridge-devops'

stages:
  # Stage 1: Build
  - stage: Build
    displayName: 'Build e Testes'
    jobs:
      - job: BuildJob
        displayName: 'Compilar e Testar'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          # Checkout do código
          - checkout: self
            fetchDepth: 0

          # Configurar .NET SDK
          - task: UseDotNet@2
            displayName: 'Instalar .NET SDK 8.0'
            inputs:
              packageType: 'sdk'
              version: '8.0.x'

          # Restaurar dependências
          - task: DotNetCoreCLI@2
            displayName: 'Restaurar pacotes NuGet'
            inputs:
              command: 'restore'
              projects: '$(projectPath)'

          - task: DotNetCoreCLI@2
            displayName: 'Restaurar pacotes de testes'
            inputs:
              command: 'restore'
              projects: '$(testProjectPath)'

          # Build do projeto
          - task: DotNetCoreCLI@2
            displayName: 'Compilar projeto'
            inputs:
              command: 'build'
              projects: '$(projectPath)'
              arguments: '--configuration $(buildConfiguration) --no-restore'

          # Build do projeto de testes
          - task: DotNetCoreCLI@2
            displayName: 'Compilar projeto de testes'
            inputs:
              command: 'build'
              projects: '$(testProjectPath)'
              arguments: '--configuration $(buildConfiguration) --no-restore'

          # Executar testes
          - task: DotNetCoreCLI@2
            displayName: 'Executar testes unitários'
            inputs:
              command: 'test'
              projects: '$(testProjectPath)'
              arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --logger "trx;LogFileName=test-results.trx"'
              continueOnError: false

          # Publicar resultados dos testes
          - task: PublishTestResults@2
            displayName: 'Publicar resultados dos testes'
            condition: always()
            inputs:
              testResultsFormat: 'VSTest'
              testResultsFiles: '$(Agent.TempDirectory)/**/*.trx'
              failTaskOnFailedTests: false

          # Publicar cobertura de código
          - task: PublishCodeCoverageResults@1
            displayName: 'Publicar cobertura de código'
            condition: always()
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'

          # Publicar artefato
          - task: DotNetCoreCLI@2
            displayName: 'Publicar artefato para deploy'
            inputs:
              command: 'publish'
              projects: '$(projectPath)'
              arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/publish --no-build'
              zipAfterPublish: false

          # Publicar artefato
          - task: PublishBuildArtifacts@1
            displayName: 'Publicar artefatos'
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)/publish'
              artifactName: 'drop'
              publishLocation: 'Container'

  # Stage 2: Release (Deploy)
  - stage: Deploy
    displayName: 'Deploy para Azure'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployJob
        displayName: 'Deploy para Azure App Service'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                # Checkout do código para executar migrações
                - checkout: self
                  fetchDepth: 0

                # Download do artefato
                - download: current
                  artifact: drop

                # Instalar .NET SDK
                - task: UseDotNet@2
                  displayName: 'Instalar .NET SDK 8.0'
                  inputs:
                    packageType: 'sdk'
                    version: '8.0.x'

                # Restaurar dependências
                - task: DotNetCoreCLI@2
                  displayName: 'Restaurar pacotes NuGet'
                  inputs:
                    command: 'restore'
                    projects: '$(projectPath)'

                # Compilar projeto
                - task: DotNetCoreCLI@2
                  displayName: 'Compilar projeto para migrations'
                  inputs:
                    command: 'build'
                    projects: '$(projectPath)'
                    arguments: '--configuration $(buildConfiguration) --no-restore'

                # Instalar EF Core Tools e Executar Migrations
                - task: Bash@3
                  displayName: 'Instalar EF Core Tools e Executar Migrations'
                  inputs:
                    targetType: 'inline'
                    script: |
                      set -e
                      
                      # Instalar EF Core Tools (força reinstalação se já existir)
                      dotnet tool install --global dotnet-ef --version 8.0.0 || dotnet tool update --global dotnet-ef --version 8.0.0
                      
                      # Adicionar ao PATH
                      export PATH="$PATH:/home/vsts/.dotnet/tools"
                      
                      # Verificar instalação
                      echo "Verificando versão do dotnet-ef:"
                      dotnet ef --version
                      
                      # Executar migrations
                      echo "Executando migrations..."
                      dotnet ef database update \
                        --project $(projectPath) \
                        --connection "$(DB_CONNECTION_STRING)" \
                        --no-build \
                        --verbose
                      
                      echo "Migrations executadas com sucesso!"
                  env:
                    ConnectionStrings__DefaultConnection: '$(DB_CONNECTION_STRING)'

                # Configurar variáveis de ambiente via Azure CLI
                - task: AzureCLI@2
                  displayName: 'Configurar variáveis de ambiente'
                  inputs:
                    azureSubscription: '$(AZURE_SERVICE_CONNECTION)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Configurando variáveis de ambiente no App Service..."
                      az webapp config appsettings set \
                        --name $(WEB_APP_NAME) \
                        --resource-group $(RESOURCE_GROUP_NAME) \
                        --settings ASPNETCORE_ENVIRONMENT=Production \
                        ConnectionStrings__DefaultConnection="$(DB_CONNECTION_STRING)" \
                        --output none
                      echo "Variáveis de ambiente configuradas com sucesso!"

                # Deploy para Azure App Service
                - task: AzureWebApp@1
                  displayName: 'Deploy para Azure App Service'
                  inputs:
                    azureSubscription: '$(AZURE_SERVICE_CONNECTION)'
                    appName: '$(WEB_APP_NAME)'
                    package: '$(Pipeline.Workspace)/drop'
                    deploymentMethod: 'auto'

                # Health check com retry
                - task: Bash@3
                  displayName: 'Verificar health check'
                  inputs:
                    targetType: 'inline'
                    script: |
                      url="$(WEB_APP_URL)/health"
                      echo "Verificando health check: $url"
                      
                      max_attempts=10
                      attempt=1
                      wait_time=10
                      
                      while [ $attempt -le $max_attempts ]; do
                        echo "Tentativa $attempt/$max_attempts..."
                        response=$(curl -s -o /dev/null -w "%{http_code}" "$url" || echo "000")
                        echo "Status HTTP: $response"
                        
                        if [ "$response" -eq 200 ]; then
                          echo "✅ Health check passou!"
                          exit 0
                        fi
                        
                        if [ $attempt -lt $max_attempts ]; then
                          echo "Aguardando $wait_time segundos antes da próxima tentativa..."
                          sleep $wait_time
                        fi
                        
                        attempt=$((attempt + 1))
                      done
                      
                      echo "❌ Health check falhou após $max_attempts tentativas"
                      exit 1
