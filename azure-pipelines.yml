# Azure Pipelines YAML - Build e Deploy
# Pipeline simplificada e otimizada para .NET 8.0 + PostgreSQL

trigger:
  branches:
    include:
      - main
      - master
  paths:
    exclude:
      - README.md
      - "*.md"

pr:
  branches:
    include:
      - main
      - master

variables:
  - group: skillbridge-variables
  - name: buildConfiguration
    value: "Release"
  - name: projectPath
    value: "SkillBridge.API/SkillBridge.API.csproj"
  - name: testProjectPath
    value: "SkillBridge.Tests/SkillBridge.Tests.csproj"
  - name: DB_CONNECTION_STRING
    value: "Host=$(DB_SERVER);Database=$(DB_NAME);Username=$(DB_USER);Password=$(DB_PASSWORD);SSL Mode=Require;Trust Server Certificate=true"
  - name: RESOURCE_GROUP_NAME
    value: "rg-skillbridge-devops"

stages:
  # Stage 1: Build
  - stage: Build
    displayName: "Build e Testes"
    jobs:
      - job: BuildJob
        displayName: "Compilar e Testar"
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self
            fetchDepth: 0

          - task: UseDotNet@2
            displayName: "Instalar .NET SDK 8.0"
            inputs:
              packageType: "sdk"
              version: "8.0.x"

          - task: DotNetCoreCLI@2
            displayName: "Restaurar pacotes"
            inputs:
              command: "restore"
              projects: |
                $(projectPath)
                $(testProjectPath)

          - task: DotNetCoreCLI@2
            displayName: "Compilar projeto"
            inputs:
              command: "build"
              projects: "$(projectPath)"
              arguments: "--configuration $(buildConfiguration) --no-restore"

          - task: DotNetCoreCLI@2
            displayName: "Compilar testes"
            inputs:
              command: "build"
              projects: "$(testProjectPath)"
              arguments: "--configuration $(buildConfiguration) --no-restore"

          - task: DotNetCoreCLI@2
            displayName: "Executar testes unitários"
            inputs:
              command: "test"
              projects: "$(testProjectPath)"
              arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --logger "trx;LogFileName=test-results.trx"'
              continueOnError: false

          - task: PublishTestResults@2
            displayName: "Publicar resultados dos testes"
            condition: always()
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "$(Agent.TempDirectory)/**/*.trx"
              failTaskOnFailedTests: false

          - task: PublishCodeCoverageResults@1
            displayName: "Publicar cobertura de código"
            condition: always()
            inputs:
              codeCoverageTool: "Cobertura"
              summaryFileLocation: "$(Agent.TempDirectory)/**/coverage.cobertura.xml"

          - task: DotNetCoreCLI@2
            displayName: "Publicar aplicação"
            inputs:
              command: "publish"
              projects: "$(projectPath)"
              arguments: "--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/publish --no-restore"
              zipAfterPublish: false
              modifyOutputPath: false

          - task: ArchiveFiles@2
            displayName: "Criar pacote ZIP"
            inputs:
              rootFolderOrFile: "$(Build.ArtifactStagingDirectory)/publish"
              includeRootFolder: false
              archiveType: "zip"
              archiveFile: "$(Build.ArtifactStagingDirectory)/drop/package.zip"
              replaceExistingArchive: true

          - task: PublishBuildArtifacts@1
            displayName: "Publicar artefatos"
            inputs:
              pathToPublish: "$(Build.ArtifactStagingDirectory)/drop"
              artifactName: "drop"
              publishLocation: "Container"

  # Stage 2: Deploy
  - stage: Deploy
    displayName: "Deploy para Azure"
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployJob
        displayName: "Deploy para Azure App Service"
        pool:
          vmImage: "ubuntu-latest"
        environment: "production"
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  fetchDepth: 0

                - download: current
                  artifact: drop

                - task: UseDotNet@2
                  displayName: "Instalar .NET SDK 8.0"
                  inputs:
                    packageType: "sdk"
                    version: "8.0.x"

                - task: DotNetCoreCLI@2
                  displayName: "Restaurar pacotes para migrations"
                  inputs:
                    command: "restore"
                    projects: "$(projectPath)"

                - task: DotNetCoreCLI@2
                  displayName: "Compilar projeto para migrations"
                  inputs:
                    command: "build"
                    projects: "$(projectPath)"
                    arguments: "--configuration $(buildConfiguration) --no-restore"

                - task: Bash@3
                  displayName: "Executar Migrations do Banco de Dados"
                  inputs:
                    targetType: "inline"
                    script: |
                      set -e
                      dotnet tool install --global dotnet-ef --version 8.0.6 || dotnet tool update --global dotnet-ef --version 8.0.6
                      export PATH="$PATH:/home/vsts/.dotnet/tools"
                      echo "Versão do dotnet-ef:"
                      dotnet ef --version
                      CONN_STR="Host=$(DB_SERVER);Database=$(DB_NAME);Username=$(DB_USER);Password=$(DB_PASSWORD);SSL Mode=Require;Trust Server Certificate=true"
                      echo "Executando migrations..."
                      timeout 300 dotnet ef database update \
                        --project $(projectPath) \
                        --connection "$CONN_STR" \
                        --no-build \
                        --verbose || {
                        EXIT_CODE=$?
                        if [ $EXIT_CODE -eq 124 ]; then
                          echo "ERRO: Timeout ao executar migrations"
                        else
                          echo "ERRO ao executar migrations (código: $EXIT_CODE)"
                        fi
                        exit $EXIT_CODE
                      }
                      echo "Migrations executadas com sucesso!"

                - task: AzureCLI@2
                  displayName: "Configurar App Service"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      echo "Configurando variáveis de ambiente..."
                      az webapp config appsettings set \
                        --name $(WEB_APP_NAME) \
                        --resource-group $(RESOURCE_GROUP_NAME) \
                        --settings ASPNETCORE_ENVIRONMENT=Production ConnectionStrings__DefaultConnection="$(DB_CONNECTION_STRING)" SCM_DO_BUILD_DURING_DEPLOYMENT=false \
                        --output none
                      echo "Configuração concluída!"

                - task: AzureWebApp@1
                  displayName: "Deploy para Azure App Service"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    appName: "$(WEB_APP_NAME)"
                    package: "$(Pipeline.Workspace)/drop/package.zip"
                    deploymentMethod: "auto"

                - task: Bash@3
                  displayName: "Verificar health check"
                  continueOnError: true
                  inputs:
                    targetType: "inline"
                    script: |
                      url="$(WEB_APP_URL)/health"
                      echo "Verificando health check: $url"
                      sleep 30
                      max_attempts=10
                      attempt=1
                      while [ $attempt -le $max_attempts ]; do
                        echo "Tentativa $attempt/$max_attempts..."
                        response=$(curl -s -o /dev/null -w "%{http_code}" "$url" 2>&1 || echo "000")
                        echo "Status HTTP: $response"
                        if [ "$response" -eq 200 ]; then
                          echo "Health check passou!"
                          exit 0
                        fi
                        if [ $attempt -lt $max_attempts ]; then
                          sleep 15
                        fi
                        attempt=$((attempt + 1))
                      done
                      echo "Aviso: Health check não passou após $max_attempts tentativas"
                      exit 0
